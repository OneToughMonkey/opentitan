"""
Contains classes that implement the functionality of a client to a serial-
connected OpenTitan device running the crypto.c example code. This module
depends on the titan_crypto module that can be autogenerated from the crypto.h
and key.h C header files and the crypto.i interface file with SWIG:

$ swig -python -py3 -builtin -castmode crypto.i
$ gcc -fpic -c crypto_wrap.c -I /usr/include/python3.X # your version
$ gcc -shared crypto_wrap.o -o _titan_crypto.so

Classes:
    OpenTitan(): a serial-connected OpenTitan device
    TitanHmac(): the HMAC peripheral of an OpenTitan device
    TitanAes(): the AES peripheral of an OpenTitan device
    CryptoRequest(abc.ABC): a cryptographic request to an OpenTitan device
        HmacRequest(CryptoRequest): a request for the HMAC peripheral
        AesRequest(CryptoRequest): a request for the AES peripheral

Global variables:
    aes_key (bytes): the 256-bit key for AES operations configured in key.h
    hmac_key (bytes): the 256-bit key for HMAC operations configured in key.h
"""

from abc import ABC, abstractmethod
from typing import Optional

from serial import Serial
from Cryptodome.Cipher import AES
from Cryptodome.Hash import SHA256
from Cryptodome.Util.Padding import pad, unpad
from Cryptodome.Random import get_random_bytes

# pylint: disable=no-member
import titan_crypto as tc  # autogenerated from C headers with SWIG

# convert keys from SWIG pointers to byte-strings for convenience access
_k = tc.uint8Array_frompointer(tc.aes_key)
aes_key = bytes(_k[i] for i in range(tc.KEY_LEN // 8))
_k = tc.uint8Array_frompointer(tc.hmac_key)
hmac_key = bytes(_k[i] for i in range(tc.KEY_LEN // 8))


class OpenTitan:
    """
    Represents a serial-connected OpenTitan device.

    Attributes:
        hmac (TitanHmac): HMAC peripheral of serial-connected OT device
        aes (TitanAes): AES peripheral of serial-connected OT device

    Properties:
        serial (serial.Serial): serial connection to OpenTitan device
    """
    def __init__(self, serial: Serial) -> None:
        """
        Parameters:
            serial (serial.Serial): serial connection to OpenTitan device
        """
        self._serial = serial
        self.hmac = TitanHmac(serial)
        self.aes = TitanAes(serial)

    @property
    def serial(self) -> Serial:
        """
        Serial connection to OpenTitan device, automatically updated on hmac
        and aes peripheral attributes.
        """
        return self._serial

    @serial.setter
    def serial(self, serial: Serial) -> None:
        self._serial = serial
        self.hmac.serial = serial
        self.aes.serial = serial


class TitanHmac:
    """
    Represents the HMAC peripheral of a serial-connected OpenTitan device.

    Attributes:
        serial (serial.Serial): serial connection to OpenTitan device

    Methods:
        mac(message): calculate HMAC-SHA256
        hash(data): calculate SHA-256
    """
    def __init__(self, serial: Serial) -> None:
        """
        Parameters:
            serial (serial.Serial): serial connection to OpenTitan device
        """
        self.serial = serial

    def _process(self, data: bytes, hmac_mode: int) -> bytes:
        req = HmacRequest(len(data), hmac_mode)
        req.send(self.serial)
        self.serial.write(data)
        if self.serial.read()[0] != tc.cryptoResponseAck:
            raise IOError(
                "OpenTitan device did not confirm digest computation")
        return self.serial.read(SHA256.digest_size)

    def mac(self, message: bytes) -> bytes:
        """
        Have the serial-connected OpenTitan device compute the HMAC-SHA256 of
        the given message with the internally stored key.

        Parameters:
            message (bytes): message to authenticate

        Returns:
            bytes: HMAC-SHA256
        """
        return self._process(message, tc.hmacModeHmac)

    def hash(self, data: bytes) -> bytes:
        """
        Have the serial-connected OpenTitan device compute the SHA-256 hash of
        the given data.

        Parameters:
            data (bytes): data to hash

        Returns:
            bytes: SHA-256 digest
        """
        return self._process(data, tc.hmacModeSha256)


class TitanAes:
    """
    Represents the AES peripheral of a serial-connected OpenTitan device.

    Attributes:
        serial (serial.Serial): serial connection to OpenTitan device
        cipher_mode (int/enum): block cipher mode of operation
            titan_crypto.cipherModeEcb /
            titan_crypto.cipherModeCbc (default) /
            titan_crypto.cipherModeCtr
        iv (bytes): 16 byte AES IV
            ignored for ECB mode, serves as nonce for CTR mode

    Methods:
        reset_iv(iv=None): reset the IV
        encrypt(data): encrypt data
        decrypt(data): decrypt data
    """
    def __init__(self,
                 serial: Serial,
                 cipher_mode: int = tc.cipherModeCbc,
                 iv: Optional[bytes] = None) -> None:
        """
        Parameters:
            serial (serial.Serial): serial connection to OpenTitan device
            cipher_mode (int/enum): block cipher mode of operation
                titan_crypto.cipherModeEcb /
                titan_crypto.cipherModeCbc (default) /
                titan_crypto.cipherModeCtr
            iv (bytes): 16 byte AES IV, initialized with random value if None
                ignored for ECB mode, serves as nonce for CTR mode
        """
        self.serial = serial
        self.cipher_mode = cipher_mode
        if iv is None:
            iv = get_random_bytes(AES.block_size)
        self.iv = iv

    @property
    def iv(self) -> bytes:
        """
        16 byte AES IV.
        Ignored for ECB mode, serves as nonce for CTR mode.
        """
        return self._iv

    @iv.setter
    def iv(self, iv: bytes) -> None:
        if not isinstance(iv, bytes):
            raise TypeError("IV has to be a bytes object")
        if len(iv) != AES.block_size:
            raise ValueError(f"length of IV != {AES.block_size}: {len(iv)}")
        self._iv = iv

    def reset_iv(self) -> None:
        """Reset the IV used for AES operations to a random value."""
        self.iv = get_random_bytes(AES.block_size)

    def encrypt(self, data: bytes) -> bytes:
        """
        Have the serial-connected OpenTitan device encrypt the given data with
        the configured AES block cipher mode and the internally stored key.

        Parameters:
            data (bytes): data to encrypt (automatically padded to multiple of
                AES block size)

        Returns:
            bytes: encrypted data
        """
        data = pad(data, AES.block_size)
        msg_len = len(data) // AES.block_size
        req = AesRequest(msg_len, self.cipher_mode, tc.aesModeEncrypt, self.iv)
        req.send(self.serial)
        ret = []
        for i in range(msg_len):
            self.serial.write(data[i * AES.block_size:(i + 1) *
                                   AES.block_size])
            if self.serial.read()[0] != tc.cryptoResponseAck:
                raise IOError(
                    f"OpenTitan device did not confirm encryption of block {i}"
                )
            ret += [self.serial.read(AES.block_size)]
        return b''.join(ret)

    def decrypt(self, data: bytes) -> bytes:
        """
        Have the serial-connected OpenTitan device decrypt the given data with
        the configured AES block cipher mode and the internally stored key.

        Parameters:
            data (bytes): data to decrypt

        Returns:
            bytes: decrypted data
        """
        if len(data) % AES.block_size:
            raise ValueError("len(data) must be multiple of AES block size")
        msg_len = len(data) // AES.block_size
        req = AesRequest(msg_len, self.cipher_mode, tc.aesModeDecrypt, self.iv)
        req.send(self.serial)
        ret = []
        for i in range(msg_len):
            self.serial.write(data[i * AES.block_size:(i + 1) *
                                   AES.block_size])
            if self.serial.read()[0] != tc.cryptoResponseAck:
                raise IOError(
                    f"OpenTitan device did not confirm decryption of block {i}"
                )
            ret += [self.serial.read(AES.block_size)]
        return unpad(b''.join(ret), AES.block_size)


class CryptoRequest(ABC):
    """
    Abstract base class representing a request data structure for a serial-
    connected OpenTitan device.

    Attributes:
        crypto_mode (int/enum): cryptographic mode of operation
            titan_crypto.crytoModeHmac (default) / titan_crypto.cryptoModeAes
        msg_len (int): length of the message data following the request

    Abstract read-only properties:
        data (bytes): serialized request data

    Methods:
        send(serial.Serial): send request over serial connection
    """
    def __init__(self,
                 msg_len: int,
                 crypto_mode: int = tc.cryptoModeHmac) -> None:
        """
        Parameters:
            msg_len (int): length of the message data following the request
            crypto_mode (int/enum): cryptographic mode of operation
                titan_crypto.crytoModeHmac (default) /
                titan_crypto.cryptoModeAes
        """
        self.msg_len = msg_len
        self.crypto_mode = crypto_mode

    def send(self, serial: Serial) -> None:
        """
        Send the serialized request data over the given serial connection and
        wait for acknowledgment of the request from the OpenTitan device.

        Parameters:
            serial (serial.Serial): serial connection to OpenTitan device

        Raises:
            IOError: when something other than a titan_client.cryptoResponseAck
                byte is read from serial connection after request transmission
        """
        serial.reset_input_buffer()
        serial.write(self.data)
        if serial.read()[0] != tc.cryptoResponseAck:
            raise IOError("OpenTitan device did not acknowledge request")

    @property
    @abstractmethod
    def data(self) -> bytes:
        """
        Abstract read-only property representing the beginning of serialized
        request data. Obtained by transforming the attributes to bytes and
        concatenating them in the order expected by the serial-connected
        OpenTitan device:
            (crypto_mode || msg_len)
        """
        return (self.crypto_mode.to_bytes(tc.CRYPTO_MODE_SIZE, tc.ENDIANNESS) +
                self.msg_len.to_bytes(tc.MSG_LEN_SIZE, tc.ENDIANNESS))


class HmacRequest(CryptoRequest):
    """
    Extends a CryptoRequest to represent an HMAC request data structure for a
    serial-connected OpenTitan device.

    Attributes:
        crypto_mode (int/enum): cryptographic mode of operation
            titan_crypto.crytoModeHmac (default) / titan_crypto.cryptoModeAes
        msg_len (int): length of the message data following the request in bytes
        hmac_mode (int/enum): HMAC peripheral mode of operation
            titan_crypto.hmacModeHmac (default) / titan_crypto.hmacModeSha256

    Read-only properties:
        data (bytes): serialized request data

    Methods:
        send(serial.Serial): send request over serial connection
    """
    def __init__(self, msg_len: int, hmac_mode: int = tc.hmacModeHmac) -> None:
        """
        Parameters:
            msg_len (int): length of the message data following the request in
                bytes
            hmac_mode (int/enum): HMAC peripheral mode of operation
                titan_crypto.hmacModeHmac (default) /
                titan_crypto.hmacModeSha256
        """
        self.hmac_mode = hmac_mode
        super().__init__(msg_len, tc.cryptoModeHmac)

    @property
    def data(self) -> bytes:
        """
        Extension of the CryptoRequest data, representing the serialized data of
        a complete HMAC request. Obtained by transforming the subclass
        attributes to bytes and concatenating them to the start of the
        superclass-provided request data in the order expected by the serial-
        connected OpenTitan device:
            (crypto_mode || msg_len || hmac_mode)
        """
        return (super().data +
                self.hmac_mode.to_bytes(tc.HMAC_MODE_SIZE, tc.ENDIANNESS))


class AesRequest(CryptoRequest):
    """
    Extends a CryptoRequest to represent an AES request data structure for a
    serial-connected OpenTitan device.

    Attributes:
        crypto_mode (int/enum): cryptographic mode of operation
            titan_crypto.crytoModeHmac (default) / titan_crypto.cryptoModeAes
        msg_len (int): length of the message data following the request in AES
            blocks (including padding!)
        cipher_mode (int/enum): AES block cipher mode of operation
            titan_crypto.cipherModeEcb /
            titan_crypto.cipherModeCbc (default) /
            titan_crypto.cipherModeCtr
        aes_mode (int/enum): AES mode of operation
            titan_crypto.aesModeEncrypt (default) / titan_crypto.aesModeDecrypt
        iv (bytes): 16 byte AES IV
                ignored for ECB mode, serves as nonce for CTR mode

    Read-only properties:
        data (bytes): serialized request data

    Methods:
        send(serial.Serial): send request over serial connection
    """
    def __init__(self,
                 msg_len: int,
                 cipher_mode: int = tc.cipherModeCbc,
                 aes_mode: int = tc.aesModeEncrypt,
                 iv: Optional[bytes] = None) -> None:
        """
        Parameters:
            msg_len (int): length of the message data following the request in
                AES blocks (including padding!)
            cipher_mode (int/enum): AES block cipher mode of operation
                titan_crypto.cipherModeEcb /
                titan_crypto.cipherModeCbc (default) /
                titan_crypto.cipherModeCtr
            aes_mode (int/enum): AES mode of operation
                titan_crypto.aesModeEncrypt (default) /
                titan_crypto.aesModeDecrypt
            iv (bytes): 16 byte AES IV, initialized with random value if None
                ignored for ECB mode, serves as nonce for CTR mode
        """
        self.cipher_mode = cipher_mode
        self.aes_mode = aes_mode
        if iv is None:
            iv = get_random_bytes(AES.block_size)
        self.iv = iv
        super().__init__(msg_len, tc.cryptoModeAes)

    @property
    def iv(self) -> bytes:
        """
        16 byte AES IV.
        Ignored for ECB mode, serves as nonce for CTR mode.
        """
        return self._iv

    @iv.setter
    def iv(self, iv: bytes) -> None:
        if not isinstance(iv, bytes):
            raise TypeError("IV has to be a bytes object")
        if len(iv) != AES.block_size:
            raise ValueError(f"length of IV != {AES.block_size}: {len(iv)}")
        self._iv = iv

    @property
    def data(self) -> bytes:
        """
        Extension of the CryptoRequest data, representing the serialized data of
        a complete AES request. Obtained by transforming the subclass attributes
        to bytes and concatenating them to the start of the superclass-provided
        request data in the order expected by the serial-connected OpenTitan
        device:
            (crypto_mode || msg_len || cipher_mode || aes_mode || iv)
        """
        return (super().data +
                self.cipher_mode.to_bytes(tc.CIPHER_MODE_SIZE, tc.ENDIANNESS) +
                self.aes_mode.to_bytes(tc.AES_MODE_SIZE, tc.ENDIANNESS) +
                self.iv)
